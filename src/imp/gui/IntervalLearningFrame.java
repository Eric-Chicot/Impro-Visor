/**
 * This Java Class is part of the Impro-Visor Application.
 *
 * Copyright (C) 2005-2015 Robert Keller and Harvey Mudd College.
 *
 * Impro-Visor is free software; you can redistribute it and/or modifyc it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * Impro-Visor is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of merchantability or fitness
 * for a particular purpose. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Impro-Visor; if not, write to the Free Software Foundation, Inc., 51 Franklin
 * St, Fifth Floor, Boston, MA 02110-1301 USA
 */

/*
 * TransformFrame.java
 *
 * Created on July 27, 2015, 4:57:53 PM
 */
package imp.gui;

import imp.com.*;
import imp.data.*;
import imp.lickgen.LickGen;
import java.awt.*;
import java.io.*;
import java.util.ArrayList;
import javax.swing.*;
import polya.Polylist;
import polya.Tokenizer;

/**
 * @author Alex Putman
  */
public class IntervalLearningFrame
        extends javax.swing.JFrame
        implements imp.Constants {

    private int themeLength = 8;
    private double themeProb = 0.4;
    private double transposeProb = 0.5;
    private double invertProb = 0.1;
    private double reverseProb = 0.1;
    private Notate notate;
    private ArrayList<String> melodyData = new ArrayList<String>();
    private int minPitch = 60;
    private int maxPitch = 82;
    private int minInterval = 0;
    private int maxInterval = 6;
    private int minDuration = 8;
    private int maxDuration = 8;
    private double totalBeats = 8;
    private double restProb = 0.1;
    private double leapProb = 0.2;
    private double chordToneWeight = 0.7;
    private double scaleToneWeight = 0.1;
    private double colorToneWeight = 0.05;
    private double chordToneDecayRate = 0.1;
    private boolean avoidRepeats = true;
    private boolean useGrammar = true;
    private boolean autoFill = true;
    private int recurrentIteration = 1;
    private LickGen lickgen;
    private CommandManager cm;

    /**
     * Number of beats per measure in the piece
     */
    private int beatsPerBar;
    /**
     * Total number of beats to represent in the solo curve graph
     */
    private int attrTotal;
    /**
     * Granularity at which to look at the bars, i.e. how many beats per
     * division
     */
    private int attrGranularity;
    /**
 
 
    /**
     * ArrayList of JTextField arrays, used to display probabilities used in
     * lick generation
     */
    private ArrayList<JTextField[]> lickPrefs = new ArrayList<JTextField[]>();
    /**
     * this will be set to true during extraction of all measures in a corpus
     */
    private boolean allMeasures = false;


    private IntervalLearningPanel intervalLearningTab;
    /**
     * Creates new LickgenFrame
     */
    public IntervalLearningFrame(Notate notate) {
        this.notate = notate;

        beatsPerBar = notate.getBeatsPerMeasure();
        attrTotal = 288; //max size of a selection (one chorus)
        attrGranularity = 1; //default

        initComponents();

        intervalLearningTab = new IntervalLearningPanel(notate);
        intervalLearningPanelHolder.add(intervalLearningTab, new GridLayout(1, 1, 1, 1));
        }


    

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        transformPane = new javax.swing.JTabbedPane();
        intervalLearningPanelHolder = new javax.swing.JPanel();
        transformMenuBar = new javax.swing.JMenuBar();
        grammarMenu1 = new javax.swing.JMenu();
        openGrammarMI1 = new javax.swing.JMenuItem();
        showLogMI1 = new javax.swing.JMenuItem();
        saveGrammarMI1 = new javax.swing.JMenuItem();
        editGrammarMI1 = new javax.swing.JMenuItem();
        useGrammarMI1 = new javax.swing.JCheckBoxMenuItem();
        generatorWindowMenu1 = new javax.swing.JMenu();
        closeWindowMI2 = new javax.swing.JMenuItem();
        cascadeMI2 = new javax.swing.JMenuItem();
        windowMenuSeparator2 = new javax.swing.JSeparator();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Interval Learning Controls");
        setMinimumSize(new java.awt.Dimension(1000, 850));
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                closeWindow(evt);
            }
        });
        getContentPane().setLayout(new java.awt.GridBagLayout());

        transformPane.setBackground(new java.awt.Color(218, 215, 215));
        transformPane.setMinimumSize(new java.awt.Dimension(1200, 700));
        transformPane.setPreferredSize(new java.awt.Dimension(1200, 700));

        intervalLearningPanelHolder.setLayout(new java.awt.GridLayout());
        transformPane.addTab("Interval Learning", intervalLearningPanelHolder);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.ipadx = 50;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        getContentPane().add(transformPane, gridBagConstraints);

        transformMenuBar.setMinimumSize(new java.awt.Dimension(115, 23));

        grammarMenu1.setMnemonic('G');
        grammarMenu1.setText("Grammar Options");
        grammarMenu1.setToolTipText("Edit or change the current grammar file.");
        grammarMenu1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                grammarMenu1ActionPerformed(evt);
            }
        });

        openGrammarMI1.setText("Load Grammar");
        openGrammarMI1.setToolTipText("Selects which grammar file to used.");
        openGrammarMI1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openGrammarMI1ActionPerformed(evt);
            }
        });
        grammarMenu1.add(openGrammarMI1);

        showLogMI1.setText("Show Log");
        showLogMI1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                showLogMI1ActionPerformed(evt);
            }
        });
        grammarMenu1.add(showLogMI1);

        saveGrammarMI1.setText("Save Grammar As ...");
        saveGrammarMI1.setToolTipText("Saves the grammar file under a specified name.");
        saveGrammarMI1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveGrammarMI1ActionPerformed(evt);
            }
        });
        grammarMenu1.add(saveGrammarMI1);

        editGrammarMI1.setText("Edit Grammar");
        editGrammarMI1.setToolTipText("Edit the current grammar using a text editor.");
        editGrammarMI1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                editGrammarMI1ActionPerformed(evt);
            }
        });
        grammarMenu1.add(editGrammarMI1);

        useGrammarMI1.setText("Use Grammar");
        useGrammarMI1.setToolTipText("Indicates whether or not a grammar should be used in lick generation. Without this, generation will be governed only by probabilities set in the fields below.");
        useGrammarMI1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                useGrammarMI1ActionPerformed(evt);
            }
        });
        grammarMenu1.add(useGrammarMI1);

        transformMenuBar.add(grammarMenu1);

        generatorWindowMenu1.setLabel("Window");
        generatorWindowMenu1.addMenuListener(new javax.swing.event.MenuListener() {
            public void menuSelected(javax.swing.event.MenuEvent evt) {
                generatorWindowMenu1MenuSelected(evt);
            }
            public void menuDeselected(javax.swing.event.MenuEvent evt) {
            }
            public void menuCanceled(javax.swing.event.MenuEvent evt) {
            }
        });

        closeWindowMI2.setMnemonic('C');
        closeWindowMI2.setText("Close Window");
        closeWindowMI2.setToolTipText("Closes the current window (exits program if there are no other windows)");
        closeWindowMI2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeWindowMI2ActionPerformed(evt);
            }
        });
        generatorWindowMenu1.add(closeWindowMI2);

        cascadeMI2.setMnemonic('A');
        cascadeMI2.setText("Cascade Windows");
        cascadeMI2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cascadeMI2ActionPerformed(evt);
            }
        });
        generatorWindowMenu1.add(cascadeMI2);
        generatorWindowMenu1.add(windowMenuSeparator2);

        transformMenuBar.add(generatorWindowMenu1);

        setJMenuBar(transformMenuBar);

        pack();
    }// </editor-fold>//GEN-END:initComponents


    /**
     * Interface to fillMelody in LickGen
     * @param beatValue
     * @param rhythmString
     * @param chordProg
     * @param start
     * @return 
     */
    public MelodyPart fillMelody(int beatValue,
                                 Polylist rhythmString,
                                 ChordPart chordProg,
                                 int start) 
      {
        //debug System.out.println("LickgenFrame: fillMelody");

        MelodyPart result = lickgen.fillMelody(minPitch,
                maxPitch,
                minInterval,
                maxInterval,
                beatValue,
                leapProb,
                rhythmString,
                chordProg,
                start,
                avoidRepeats);

        //debug System.out.println("fillMelody returns");
        return result;
    }

    public void stopPlaying() {
        notate.stopPlaying();
    }

                        private void showLogMI1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_showLogMI1ActionPerformed
 
                        }//GEN-LAST:event_showLogMI1ActionPerformed

                        private void saveGrammarMI1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveGrammarMI1ActionPerformed
                            notate.saveGrammarAs();
                        }//GEN-LAST:event_saveGrammarMI1ActionPerformed

                        private void editGrammarMI1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_editGrammarMI1ActionPerformed
                            notate.editGrammar();
                        }//GEN-LAST:event_editGrammarMI1ActionPerformed

                        private void useGrammarMI1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_useGrammarMI1ActionPerformed
                            
                        }//GEN-LAST:event_useGrammarMI1ActionPerformed

                        private void grammarMenu1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_grammarMenu1ActionPerformed
                            // TODO add your handling code here:
                        }//GEN-LAST:event_grammarMenu1ActionPerformed

                        private void closeWindowMI2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeWindowMI2ActionPerformed
                            closeWindow();
                        }//GEN-LAST:event_closeWindowMI2ActionPerformed
    public void closeWindow() {
        this.setVisible(false);

        WindowRegistry.unregisterWindow(this);
    }


                        private void cascadeMI2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cascadeMI2ActionPerformed
                            WindowRegistry.cascadeWindows(this);
                        }//GEN-LAST:event_cascadeMI2ActionPerformed

                        private void generatorWindowMenu1MenuSelected(javax.swing.event.MenuEvent evt) {//GEN-FIRST:event_generatorWindowMenu1MenuSelected

                            generatorWindowMenu1.removeAll();

                            generatorWindowMenu1.add(closeWindowMI2);

                            generatorWindowMenu1.add(cascadeMI2);

                            generatorWindowMenu1.add(windowMenuSeparator2);

                            for (WindowMenuItem w : WindowRegistry.getWindows()) {

                                generatorWindowMenu1.add(w.getMI(this));      // these are static, and calling getMI updates the name on them too in case the window title changed
                            }

                            generatorWindowMenu1.repaint();

                        }//GEN-LAST:event_generatorWindowMenu1MenuSelected

                        private void closeWindow(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_closeWindow
                            closeWindow();
                        }//GEN-LAST:event_closeWindow

    private void openGrammarMI1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openGrammarMI1ActionPerformed
        notate.openGrammar();
    }//GEN-LAST:event_openGrammarMI1ActionPerformed

/**
 * Fill an abstract or relative-pitch melody from text, such as acquired from
 * either abstract melody or relative pitch melody field.
 * If the text is not already a Polylist, this will first make a Polylist
 * out of it.
 *
 * @param r
 */
public void fillMelodyFromText(String r)
  {
    r = r.trim();
    if( r.equals("") )
      {
        return; // no text specified
      }
    if( r.charAt(0) != '(' )
      {
        r = "(".concat(r);
      }

    if( r.charAt(r.length() - 1) != ')' )
      {
        r = r.concat(")");
      }

    Polylist rhythm = new Polylist();
    StringReader rhythmReader = new StringReader(r);
    Tokenizer in = new Tokenizer(rhythmReader);
    Object ob;

    while( (ob = in.nextSexp()) != Tokenizer.eof )
      {
        if( ob instanceof Polylist )
          {
            rhythm = (Polylist) ob;
          }
      }

    notate.generateAndPutLick(rhythm);
  }

public MelodyPart fillAndReturnMelodyFromText(String r, ChordPart chordPart)
  {
    r = r.trim();
    if( r.equals("") )
      {
        return new MelodyPart(); // no text specified
      }
    if( r.charAt(0) != '(' )
      {
        r = "(".concat(r);
      }

    if( r.charAt(r.length() - 1) != ')' )
      {
        r = r.concat(")");
      }

    Polylist rhythm = new Polylist();
    StringReader rhythmReader = new StringReader(r);
    Tokenizer in = new Tokenizer(rhythmReader);
    Object ob;

    while( (ob = in.nextSexp()) != Tokenizer.eof )
      {
        if( ob instanceof Polylist )
          {
            rhythm = (Polylist) ob;
          }
      }

    return notate.generateLick(rhythm, chordPart);
  }

    private boolean saveImp = false;
    public void setSaveImp(boolean value)
    {
        saveImp = value;
    }
    public boolean shouldSaveImp(){
        return saveImp;
    }

    // Return min duration text field
    public int getMinDuration() {
        return minDuration;
    }

    // Return max duration text field
    public int getMaxDuration() {
        return maxDuration;
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem cascadeMI2;
    private javax.swing.JMenuItem closeWindowMI2;
    private javax.swing.JMenuItem editGrammarMI1;
    private javax.swing.JMenu generatorWindowMenu1;
    private javax.swing.JMenu grammarMenu1;
    private javax.swing.JPanel intervalLearningPanelHolder;
    private javax.swing.JMenuItem openGrammarMI1;
    private javax.swing.JMenuItem saveGrammarMI1;
    private javax.swing.JMenuItem showLogMI1;
    private javax.swing.JMenuBar transformMenuBar;
    private javax.swing.JTabbedPane transformPane;
    private javax.swing.JCheckBoxMenuItem useGrammarMI1;
    private javax.swing.JSeparator windowMenuSeparator2;
    // End of variables declaration//GEN-END:variables



    public void setTotalBeats(double beats) {
        totalBeats = beats;
        String b = Integer.toString((int) beats);

    }

}
